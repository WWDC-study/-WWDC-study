# UIViewController
better on: [UIViewController](https://enebin.notion.site/UIViewController-cfeeb7c9f4b14d3fa739d8bc61537063)

`UIViewController`는 UIKit에서 뷰 계층을 관리하는 객체입니다.

## UIViewController 개요

---

`UIViewController`는 모든 뷰 컨트롤러에 공통적으로 적용되는 공유 동작을 정의합니다. `UIViewController`를 직접 생성하는 경우는 거의 없으며 대개 `UIViewController`를 서브 클래싱해 필요한 메서드와 속성을 추가합니다.

### 역할

`UIViewController`의 주요한 역할은 다음과 같습니다:

- 뷰 콘텐츠 업데이트(주로 데이터의 변경에 대한 응답에 의해)
- 사용자의 상호 작용에 응답
- 뷰 크기 조정 및 인터페이스 레이아웃 관리
- 앱에서 다른 개체(다른 뷰 컨트롤러 포함)와 협응

### 이벤트 핸들링(리스폰더 체인)

뷰 컨트롤러는 자신이 관리하는 뷰와 긴밀하게(tightly) 연결되어 있으며 뷰 계층 구조에서 이벤트를 처리하는 데 참여합니다. 

- 뷰 컨트롤러는 `UIResponder` 객체이며 뷰 컨트롤러의 루트 뷰와 해당 뷰의 슈퍼뷰(일반적으로 다른 뷰 컨트롤러에 속함)들 과의 responder chain 사이에 위치합니다.
- 뷰 컨트롤러가 관리하는 뷰 중 이벤트를 처리할 수 있는 뷰가 없는 경우 뷰 컨트롤러는 이벤트를 자신이 직접 처리하거나 슈퍼 뷰로 전달할 수 있습니다.

### 사용

뷰 컨트롤러를 단독으로 사용하는 경우는 거의 없습니다. 대개 여러 개의 뷰 컨트롤러를 함께 사용하며, 각 뷰 컨트롤러는 앱 사용자 인터페이스의 일부를 가지고 있습니다. 

- 예를 들어 한 뷰 컨트롤러는 항목의 테이블을 표시하고 다른 뷰 컨트롤러는 해당 테이블에서 선택한 항목을 표시할 수 있습니다.
- 일반적으로 한 번에 한 뷰 컨트롤러의 뷰만 표시합니다. 뷰 컨트롤러는 새 뷰를 표시하기 위해 다른 뷰 컨트롤러를 표시하거나 다른 뷰 컨트롤러의 콘텐츠를 위한 컨테이너 역할을 하며 애니메이션을 적용하는 등의 역할을 할 수도 있습니다.

### 서브클래싱

모든 앱에는 `UIViewController`의 커스텀 하위 클래스가 하나 이상 포함되어 있습니다. 커스텀 뷰 컨트롤러에는 앱의 디자인과 상호 작용 처리를 포함해 앱의 전반적인 동작을 정의할 수 있습니다. 

### 뷰 관리

각 뷰 컨트롤러는 뷰 계층을 관리하며 계층의 루트 뷰는 뷰 컨트롤러의 `view`에 저장됩니다.

- 루트 뷰는 주로 나머지 뷰 계층 구조에 대한 컨테이너 역할을 합니다. 루트 뷰의 크기와 위치는 상위 뷰 컨트롤러 또는 앱의 `window`와 같이 루트 뷰를 소유하는 객체에 의해 결정됩니다.
- 앱의 *루트 뷰 컨트롤러*는 `window`가 소유하고 있으며 해당 뷰의 크기는 창을 가득 채우도록 조정됩니다.

뷰 컨트롤러는 자신의 뷰를 게으르게(lazy) 로드합니다. 즉 `view`에 최초로 액세스할 때 뷰 컨트롤러의 뷰를 로드합니다. 

**뷰 컨트롤러의** `view`**를 로드하는 방법에는 여러 가지가 있습니다:**

- **스토리보드**
    - 스토리보드는 `view`를 지정하는 가장 일반적인 방법입니다. 스토리보드를 사용해 뷰와 뷰 컨트롤러를 연결할 수 있으며 세그웨이를 지정하여 동작을 정의할 수 있습니다.
    - 스토리보드로부터 뷰 컨트롤러를 로드할 때 `UIStoryboard`의 `instantiateViewController(withIdentifier:)` 메서드를 호출합니다. 이 메서드는 스토리보드로부터 뷰 컨트롤러를 생성한 후 이를 반환합니다.
- `**nib` 파일**
    - `nib` 파일을 사용하면 한가지 뷰 컨트롤러의 뷰를 지정할 수 있습니다. 하지만 뷰 컨트롤러 간의 관계(relation) 혹은 세그웨이를 정의할 수는 없습니다.
    - `nib` 파일을 사용하여 뷰 컨트롤러 개체를 초기화하려면 코드로 뷰 컨트롤러 클래스를 생성한 후  `init(nibName:bundle:)` 메서드를 사용해 초기화합니다.
    - 뷰를 요청하면 뷰 컨트롤러는 `nib` 파일에서 뷰를 로드합니다.
- `[**loadView()**](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621454-loadview)`
    - 뷰 계층 구조를 직접 만들 수 있습니다. 이 메서드를 이용하면 해당 계층에서 루트 뷰에 해당하는 뷰를 뷰 컨트롤러에 할당합니다.
    - (문서에 의하면) 가급적 직접 호출하는 일은 없어야 합니다.

***Tips***

- 뷰 컨트롤러의 루트 뷰는 항상 할당된 공간에 맞게 크기가 조정됩니다.
- 인터페이스 빌더를 사용하여 `AutoLayout` contraint을 지정하고 뷰 사이의 레이아웃을 지정할 수 있습니다.
- 코드로 contraint을 만드는 것도 가능하며 이를 이용하면 런타임에 contraint를 추가할 수 있습니다.

### 컨테이너

컨테이너 뷰 컨트롤러는 자식(`child`) 뷰 컨트롤러라고도 하는 다른 뷰 컨트롤러를 소유하며 콘텐츠를 관리할 수 있습니다.

- 컨테이너 뷰 컨트롤러는 자식들을 연결하기 위한 공용 인터페이스를 선언해야 합니다. 또한 뷰 컨트롤러에서 한 번에 표시할 수 있는 자식 수, 자식이 표시되는 시기 및 뷰 계층에서 자식이 표시되는 위치를 결정해야 합니다.
- 공용 인터페이스를 적절히 설정할 경우 컨테이너가 자식의 내부 구현에 액세스하지 않고도 많은 기능을 사용하고 구현할 수 있습니다.

컨테이너 뷰 컨트롤러는 자식의 루트 뷰를 뷰 계층에 추가하기 전에 자식 뷰 컨트롤러를 자신과 연결해야 합니다. 

**호출해야 할 메서드는 다음과 같습니다:**

- `addChild(_:)`
- `removeFromParent()`
- `willMove(toParent:)`
- `didMove(toParent:)`

## 정리

---

- `UIViewController`는 뷰 컨트롤러에 공통적인 동작을 정의하며, 뷰 콘텐츠 업데이트, 사용자 상호 작용, 뷰 크기 조정, 앱 내 다른 객체와 협력하는 역할을합니다.
- `UIViewController`는 이벤트 처리를 할 수 있는  `UIResponder` 객체이며 루트 뷰와 슈퍼뷰 간의 responder chain 사이에 위치합니다.
- `UIViewController`는 서브 클래스를 통해 커스텀 뷰 컨트롤러를 만들 수 있으며 다른 뷰 컨트롤러의 콘텐츠를 위한 컨테이너 역할을 할 수 있으며,

## 참고