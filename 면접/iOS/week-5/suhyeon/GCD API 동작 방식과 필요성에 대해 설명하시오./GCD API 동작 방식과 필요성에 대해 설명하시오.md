# GCD API 동작 방식과 필요성에 대해 설명하시오.

### GCD?

- 공식문서 정의 
멀티코어 하드웨어에서 작업을 동시에 실행할 수 있도록 지원해주는 프레임워크
- 개발자를 대신하여 운영체제가 스레드를 관리해준다. 
프로그래머가 쉽게 비동기 프로그래밍을 할 수 있게 해준다.
- 개발자는 동시성 프로그래밍을 하기 위해, DispatchQueue에 작업을 전달하기만 하면 된다.
→ GCD가 자동으로 스레드 생성하여 작업 실행
- 저수준 API이다.
    - 시스템 레벨에서 동작한다.

## DispatchQueue

---

- class
- 역할: Task의 실행을 관리, Task를 동시에 실행할 수 있게 해준다.
- FIFO Queue
- DispatchQueue에 쌓인 작업은 시스템에서 관리하는 스레드 풀에서 실행된다.
- 메인 스레드를 제외하고, 어떤 작업이 특정 스레드에서 실행되는 것을 보장 X
- DispatchQueue에 작업을 전달할 때, **작업이 동기식으로 실행되도록 / 비동기적으로 실행되도록 예약 가능**
    - 동기 실행 vs 비동기 실행 차이
        
        동기 실행: 작업이 실행완료될 때까지 코드 대기
        
        비동기 실행: 작업이 실행되는 동안, 코드가 계속 실행됨
        
- `MainQueue에 작업을 동기적으로 전달하면 데드락을 발생시킨다!!` 
⇒ (queue가 serial인지, concurrent인지가 중요!)

### 과도하게 많은 스레드가 생성되는 것을 예방하는 방법

1. **현재 스레드를 블락시키는 메서드를 호출하지 말것!**
    - 스레드를 블락시키는 작업을 concurrent dispatch queue에 전달하면, 시스템은 큐에 들어온 다른 작업을 처리하기 위해 스레드를 생성한다.
    - 스레드를 블락시키는 작업이 많아지면, 스레드가 과도하게 생성된다.
    - 스레드 스위칭이 많이 일어나면서, 퍼포먼스 저하됨
2. **너무 많이 private dispatch queue를 생성하지 말것!**

### Queue 종류와 동작방식

- DispatchQueue에 작업(Task)를 넣으면, GCD가 알맞은 스레드에서 해당 작업이 처리될 수 있도록 한다.
- Queue이기 때문에, FIFO
- 4가지 타입의 큐 존재
    - Serial(작업을 순차적으로 처리)
    /Concucrrent(작업을 동시에 처리, 여러 스레드 사용)
    - sync(실행중이 작업이 종료되어야 cpu 실행 권한 반환 = queue로 전달한 작업이 끝날 때까지 대기 )
    /async(작업이 완료될 때까지 cpu 실행권한 반환X = queue로 전달한 작업이 끝날때가지 대기X)
    - sync async 그림으로 설명
        
        ![Untitled](GCD%20API%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%A8%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%AD%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8B%E1%85%A6%20%E1%84%83%E1%85%A2%E1%84%92%E1%85%A2%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%84%89%E1%85%B5%20e0434c31fe8d42b38c467b0f0def0d62/Untitled.png)
        
        ![Untitled](GCD%20API%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%A8%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%AD%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8B%E1%85%A6%20%E1%84%83%E1%85%A2%E1%84%92%E1%85%A2%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%84%89%E1%85%B5%20e0434c31fe8d42b38c467b0f0def0d62/Untitled%201.png)
        
        - 6초 걸림
- 프로그래머가 이용하는 큐의 종류와 타입
    1. Main Queue
    - 메인 스레드
    - Serial Queue
    - UI업데이트시 사용함
    1. Global Queue
    - 백그라운드 스레드
    - Concurrent Queue
    - 전체 시스템에 존재하는 프로세스들간에 공유하는 큐
    1. Custom Queue
    - 개발자가 직접 생성하는 큐
    - Serial/Concurrent

### 필요성

- 비동기 프로그래밍을 하기 위해, 이전에는 개발자가 스레드를 만들고 관리해야 했음.
**개발자가 스레드 관리를 신경쓰지 않고, DispatchQueue에 비동기로 실행할 작업을 넘겨주면 되어서 매우 편리**
    - 전에는 비동기 프로그래밍을 하기 위해, 개발자가 직접 스레드를 생성하고, 스레드 풀을 관리해야 했다. 매우 불편했음

### 적절한 qos를 설정하면, 더 효율적으로 비동기프로그래밍을 할 수 있다.

private dispatch queue를 만들어서 사용할 수 있다.

```swift
let mineQueue = DispatchQueue(label: "bbb", attributes: .concurrent)
//명시적으로 지정해줌으로서 큐의 속성을 정의
//정의하지 않으면 Serial Queue
```

## NSOperationQueue ↔ GCD

간단한 비동기 작업의 경우 NSOperationQueue보다 GCD를 쓰는 것이 구현이 쉽다.

NSOperationQueue보다 빠르고 오버헤드가 적기 때문에 복잡한 로직이 아니면 GCD를 사용하는 것이 편하다.